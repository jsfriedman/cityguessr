This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repopack on: 2025-04-04T10:22:17.371Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repopack's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

For more information about Repopack, visit: https://github.com/yamadashy/repopack

================================================================
Repository Structure
================================================================
docker/
  docker-compose.yml
  docker-ignore.txt
  dockerfile
  init.sql.txt
public/
  index.html
  index.js
  styles.css
csvLoader.js
package.json
server.js

================================================================
Repository Files
================================================================

================
File: docker/docker-compose.yml
================
services:
  # PostgreSQL database
  db:
    image: postgres:14-alpine
    container_name: city-game-db
    restart: unless-stopped
    environment:
      POSTGRES_USER: postgres
      POSTGRES_PASSWORD: postgres
      POSTGRES_DB: city_game
    ports:
      - "5432:5432"
    volumes:
      - postgres_data:/var/lib/postgresql/data
      - ./docker/init.sql:/docker-entrypoint-initdb.d/init.sql  # Initialize database with schema
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U postgres"]
      interval: 5s
      timeout: 5s
      retries: 5

  # Node.js application
  app:
    build:
      context: ..  # Go up one directory level to find the root
      dockerfile: ./docker/Dockerfile
    container_name: city-game-app
    restart: unless-stopped
    depends_on:
      db:
        condition: service_healthy
    environment:
      NODE_ENV: development
      DB_HOST: db
      DB_USER: postgres
      DB_PASSWORD: postgres
      DB_NAME: city_game
      DB_PORT: 5432
    ports:
      - "3000:3000"
    volumes:
      - ../:/app  # Mount from parent directory
      - /app/node_modules
    command: sh -c "npm install && npm run load-csv && npm run dev"

volumes:
  postgres_data:

================
File: docker/docker-ignore.txt
================
# Node modules
node_modules

# Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*

# Environment variables
.env
.env.local
.env.development.local
.env.test.local
.env.production.local

# Docker files (to prevent recursion)
Dockerfile
docker-compose*.yml

# CSV data files (except our main cities.csv)
*.csv
!cities.csv

# Git files
.git
.gitignore

# IDE files
.idea
.vscode
*.swp
*.swo

# Build files
build
dist

# Temporary files
tmp
temp

================
File: docker/dockerfile
================
# Use Node.js LTS as base image
FROM node:18-alpine

# Set working directory
WORKDIR /app

# Copy package.json and package-lock.json
COPY package*.json ./
COPY cities.csv ./

# Install dependencies
RUN npm install

# Copy project files
COPY . .

# Create directory structure for static files
RUN mkdir -p ./public

# Expose the port the app runs on
EXPOSE 3000

# Command to run the application
CMD ["npm", "start"]

================
File: docker/init.sql.txt
================
-- The database is created by PostgreSQL initialization
-- This script will run automatically when the container starts

-- Create tables for the city guessing game
CREATE TABLE IF NOT EXISTS cities (
  id SERIAL PRIMARY KEY,
  city VARCHAR(100) NOT NULL,
  city_ascii VARCHAR(100) NOT NULL,
  city_alt VARCHAR(100),
  lat DECIMAL(9,6) NOT NULL,
  lng DECIMAL(9,6) NOT NULL,
  country VARCHAR(100) NOT NULL,
  iso2 CHAR(2) NOT NULL,
  iso3 CHAR(3) NOT NULL,
  admin_name VARCHAR(100),
  admin_name_ascii VARCHAR(100),
  admin_code VARCHAR(50),
  admin_type VARCHAR(50),
  capital VARCHAR(50),
  density DECIMAL(15,2),
  population BIGINT,
  population_proper BIGINT,
  ranking INT,
  timezone VARCHAR(50),
  same_name BOOLEAN,
  original_id VARCHAR(50)
);

-- Create scores table
CREATE TABLE IF NOT EXISTS scores (
  id SERIAL PRIMARY KEY,
  username VARCHAR(50) NOT NULL,
  score INTEGER NOT NULL,
  game_mode VARCHAR(20) NOT NULL,
  rounds INTEGER NOT NULL,
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- Create guesses table to store detailed game history
CREATE TABLE IF NOT EXISTS guesses (
  id SERIAL PRIMARY KEY,
  score_id INTEGER REFERENCES scores(id) ON DELETE CASCADE,
  round_number INTEGER NOT NULL,
  actual_city_id INTEGER REFERENCES cities(id),
  guessed_city_id INTEGER REFERENCES cities(id),
  distance DECIMAL(10,2) NOT NULL,
  points INTEGER NOT NULL
);

-- Add indexes for better performance
CREATE INDEX IF NOT EXISTS idx_cities_iso2 ON cities(iso2);
CREATE INDEX IF NOT EXISTS idx_cities_population ON cities(population);
CREATE INDEX IF NOT EXISTS idx_cities_name ON cities(city, city_ascii);
CREATE INDEX IF NOT EXISTS idx_scores_game_mode ON scores(game_mode);
CREATE INDEX IF NOT EXISTS idx_guesses_score_id ON guesses(score_id);

================
File: public/index.html
================
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>City Guessing Game</title>
  
  <!-- Leaflet CSS -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.7.1/dist/leaflet.css" />
  
  <!-- Custom CSS -->
  <link rel="stylesheet" href="styles.css">
</head>
<body>
  <div id="app"></div>
  
  <!-- Leaflet JS -->
  <script src="https://unpkg.com/leaflet@1.7.1/dist/leaflet.js"></script>
  
  <!-- Custom JS -->
  <script src="index.js"></script>
</body>
</html>

================
File: public/index.js
================
// index.js - Main application file

// Game Configuration
const gameConfig = {
  gameMode: 'medium', // 'easy', 'medium', 'hard'
  filters: {
    countries: [], // empty means all countries
    minPopulation: 100000,
    maxCities: 5
  },
  mapSettings: {
    countryBorders: true,
    stateBorders: false,
    terrainLayer: false
  },
  inputMode: 'autocomplete', // 'dropdown', 'autocomplete', 'freetext'
  currentRound: 0,
  totalRounds: 5,
  score: 0,
  username: '',
  currentCity: null,
  guessedCities: []
};

// Initialize map
let map;
let markers = [];

// Initialize app
document.addEventListener('DOMContentLoaded', () => {
  setupUI();
  initializeMap();
  setupEventListeners();
  showStartScreen();
});

// UI Setup
function setupUI() {
  const appContainer = document.getElementById('app');
  appContainer.innerHTML = `
    <div class="game-container">
      <div id="start-screen" class="screen">
        <h1>City Guessing Game</h1>
        <div class="form-group">
          <label for="username">Enter Username:</label>
          <input type="text" id="username" class="input-field">
        </div>
        <div class="form-group">
          <label for="game-mode">Select Difficulty:</label>
          <select id="game-mode" class="select-field">
            <option value="easy">Easy</option>
            <option value="medium" selected>Medium</option>
            <option value="hard">Hard</option>
          </select>
        </div>
        <button id="start-game" class="btn primary-btn">Start Game</button>
        <button id="settings-btn" class="btn secondary-btn">Advanced Settings</button>
      </div>

      <div id="settings-screen" class="screen hidden">
        <h2>Game Settings</h2>
        <div class="settings-group">
          <h3>Region Filters</h3>
          <div class="form-group">
            <label for="country-select">Countries:</label>
            <select id="country-select" class="select-field" multiple>
              <!-- Will be populated from database -->
            </select>
          </div>
          <div class="form-group">
            <label for="min-population">Minimum City Population:</label>
            <input type="range" id="min-population" min="0" max="10000000" step="50000" value="100000">
            <span id="min-population-value">100,000</span>
          </div>
        </div>
        
        <div class="settings-group">
          <h3>Map Display</h3>
          <div class="checkbox-group">
            <input type="checkbox" id="country-borders" checked>
            <label for="country-borders">Show Country Borders</label>
          </div>
          <div class="checkbox-group">
            <input type="checkbox" id="state-borders">
            <label for="state-borders">Show State/Provincial Borders</label>
          </div>
          <div class="checkbox-group">
            <input type="checkbox" id="terrain-layer">
            <label for="terrain-layer">Show Terrain</label>
          </div>
        </div>
        
        <div class="settings-group">
          <h3>Input Mode</h3>
          <div class="radio-group">
            <input type="radio" id="input-dropdown" name="input-mode" value="dropdown">
            <label for="input-dropdown">Multiple Choice Dropdown</label>
          </div>
          <div class="radio-group">
            <input type="radio" id="input-autocomplete" name="input-mode" value="autocomplete" checked>
            <label for="input-autocomplete">Typing with Autocomplete</label>
          </div>
          <div class="radio-group">
            <input type="radio" id="input-freetext" name="input-mode" value="freetext">
            <label for="input-freetext">Typing without Autocomplete</label>
          </div>
        </div>
        
        <button id="save-settings" class="btn primary-btn">Save Settings</button>
        <button id="cancel-settings" class="btn secondary-btn">Cancel</button>
      </div>

      <div id="game-screen" class="screen hidden">
        <div class="game-header">
          <div class="score-display">
            <span>Score: <span id="current-score">0</span></span>
          </div>
          <div class="round-display">
            <span>Round: <span id="current-round">1</span>/<span id="total-rounds">5</span></span>
          </div>
        </div>
        
        <div id="map-container"></div>
        
        <div class="guess-container">
          <div id="dropdown-input" class="input-container hidden">
            <label for="city-dropdown">Select the city:</label>
            <select id="city-dropdown" class="select-field">
              <!-- Will be populated with options -->
            </select>
          </div>
          
          <div id="text-input" class="input-container">
            <label for="city-input">Which city is this?</label>
            <input type="text" id="city-input" class="input-field" placeholder="Type city name...">
            <div id="autocomplete-suggestions" class="hidden"></div>
          </div>
          
          <button id="submit-guess" class="btn primary-btn">Submit Guess</button>
        </div>
      </div>

      <div id="result-screen" class="screen hidden">
        <h2>Round Result</h2>
        <div class="result-details">
          <p>The city was: <span id="actual-city">City Name</span></p>
          <p>Your guess: <span id="guessed-city">Your Guess</span></p>
          <p>Distance: <span id="distance">0</span> km</p>
          <p>Points earned: <span id="points-earned">0</span></p>
        </div>
        <button id="next-round" class="btn primary-btn">Next Round</button>
      </div>

      <div id="game-over-screen" class="screen hidden">
        <h2>Game Over</h2>
        <div class="final-score">
          <p>Final Score: <span id="final-score">0</span></p>
        </div>
        <div id="guesses-summary"></div>
        <button id="save-score" class="btn primary-btn">Save Score</button>
        <button id="play-again" class="btn secondary-btn">Play Again</button>
      </div>
    </div>
  `;
}

// Map Initialization
function initializeMap() {
  map = L.map('map-container', {
    center: [20, 0],
    zoom: 2,
    zoomControl: true,
    attributionControl: true
  });

  // Base tile layer
  L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
    attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
  }).addTo(map);

  // Add additional layers based on settings
  updateMapLayers();
}

// Update map layers based on current settings
function updateMapLayers() {
  if (gameConfig.mapSettings.terrainLayer) {
    // Add terrain layer
    L.tileLayer('https://stamen-tiles-{s}.a.ssl.fastly.net/terrain/{z}/{x}/{y}{r}.png', {
      attribution: 'Map tiles by <a href="http://stamen.com">Stamen Design</a>'
    }).addTo(map);
  }

  if (gameConfig.mapSettings.countryBorders) {
    // Add country borders layer
    fetch('/api/geojson/countries')
      .then(response => response.json())
      .then(data => {
        L.geoJSON(data, {
          style: {
            color: '#3388ff',
            weight: 2,
            opacity: 0.7,
            fillOpacity: 0
          }
        }).addTo(map);
      });
  }

  if (gameConfig.mapSettings.stateBorders) {
    // Add state/provincial borders layer
    fetch('/api/geojson/states')
      .then(response => response.json())
      .then(data => {
        L.geoJSON(data, {
          style: {
            color: '#9932CC',
            weight: 1,
            opacity: 0.5,
            fillOpacity: 0
          }
        }).addTo(map);
      });
  }
}

// Event listeners setup
function setupEventListeners() {
  // Start screen
  document.getElementById('start-game').addEventListener('click', startGame);
  document.getElementById('settings-btn').addEventListener('click', showSettingsScreen);
  document.getElementById('game-mode').addEventListener('change', handleGameModeChange);

  // Settings screen
  document.getElementById('save-settings').addEventListener('click', saveSettings);
  document.getElementById('cancel-settings').addEventListener('click', hideSettingsScreen);
  document.getElementById('min-population').addEventListener('input', updatePopulationDisplay);

  // Game screen
  document.getElementById('submit-guess').addEventListener('click', submitGuess);
  document.getElementById('city-input').addEventListener('input', handleCityInput);

  // Result screen
  document.getElementById('next-round').addEventListener('click', nextRound);

  // Game over screen
  document.getElementById('save-score').addEventListener('click', saveScore);
  document.getElementById('play-again').addEventListener('click', resetGame);
}

function showStartScreen() {
  hideAllScreens();
  document.getElementById('start-screen').classList.remove('hidden');
}

function showSettingsScreen() {
  hideAllScreens();
  document.getElementById('settings-screen').classList.remove('hidden');
  loadCountriesForMultiselect();
}

function hideSettingsScreen() {
  hideAllScreens();
  document.getElementById('start-screen').classList.remove('hidden');
}

function hideAllScreens() {
  const screens = document.querySelectorAll('.screen');
  screens.forEach(screen => screen.classList.add('hidden'));
}

function updatePopulationDisplay() {
  const value = document.getElementById('min-population').value;
  document.getElementById('min-population-value').textContent = parseInt(value).toLocaleString();
}

function handleGameModeChange(e) {
  const mode = e.target.value;
  switch (mode) {
    case 'easy':
      gameConfig.inputMode = 'dropdown';
      gameConfig.mapSettings.countryBorders = true;
      gameConfig.mapSettings.stateBorders = false;
      gameConfig.mapSettings.terrainLayer = true;
      break;
    case 'medium':
      gameConfig.inputMode = 'autocomplete';
      gameConfig.mapSettings.countryBorders = true;
      gameConfig.mapSettings.stateBorders = false;
      gameConfig.mapSettings.terrainLayer = false;
      break;
    case 'hard':
      gameConfig.inputMode = 'freetext';
      gameConfig.mapSettings.countryBorders = false;
      gameConfig.mapSettings.stateBorders = false;
      gameConfig.mapSettings.terrainLayer = false;
      break;
  }
  
  // Update UI to reflect the new settings
  updateSettingsUI();
}

function updateSettingsUI() {
  document.getElementById('country-borders').checked = gameConfig.mapSettings.countryBorders;
  document.getElementById('state-borders').checked = gameConfig.mapSettings.stateBorders;
  document.getElementById('terrain-layer').checked = gameConfig.mapSettings.terrainLayer;
  
  // Update input mode radio buttons
  document.getElementById(`input-${gameConfig.inputMode}`).checked = true;
}

function saveSettings() {
  // Update game config with settings values
  gameConfig.mapSettings.countryBorders = document.getElementById('country-borders').checked;
  gameConfig.mapSettings.stateBorders = document.getElementById('state-borders').checked;
  gameConfig.mapSettings.terrainLayer = document.getElementById('terrain-layer').checked;
  
  // Get selected input mode
  const inputModes = document.getElementsByName('input-mode');
  for (const mode of inputModes) {
    if (mode.checked) {
      gameConfig.inputMode = mode.value;
      break;
    }
  }
  
  // Get minimum population
  gameConfig.filters.minPopulation = parseInt(document.getElementById('min-population').value);
  
  // Get selected countries
  const countrySelect = document.getElementById('country-select');
  gameConfig.filters.countries = Array.from(countrySelect.selectedOptions).map(option => option.value);
  
  hideSettingsScreen();
}

function startGame() {
  const usernameInput = document.getElementById('username');
  const username = usernameInput.value.trim();
  
  if (!username) {
    alert('Please enter a username');
    return;
  }
  
  gameConfig.username = username;
  gameConfig.gameMode = document.getElementById('game-mode').value;
  gameConfig.currentRound = 1;
  gameConfig.score = 0;
  gameConfig.guessedCities = [];
  
  // Update UI
  document.getElementById('current-score').textContent = '0';
  document.getElementById('current-round').textContent = '1';
  document.getElementById('total-rounds').textContent = gameConfig.totalRounds;
  
  // Show game screen
  hideAllScreens();
  document.getElementById('game-screen').classList.remove('hidden');
  
  // Configure input based on selected mode
  setupInputMode();
  
  // Start first round
  startRound();
}

function setupInputMode() {
  const dropdownInput = document.getElementById('dropdown-input');
  const textInput = document.getElementById('text-input');
  const autocompleteSuggestions = document.getElementById('autocomplete-suggestions');
  
  switch (gameConfig.inputMode) {
    case 'dropdown':
      dropdownInput.classList.remove('hidden');
      textInput.classList.add('hidden');
      loadDropdownOptions();
      break;
    case 'autocomplete':
      dropdownInput.classList.add('hidden');
      textInput.classList.remove('hidden');
      autocompleteSuggestions.classList.remove('hidden');
      break;
    case 'freetext':
      dropdownInput.classList.add('hidden');
      textInput.classList.remove('hidden');
      autocompleteSuggestions.classList.add('hidden');
      break;
  }
}

function loadDropdownOptions() {
  const dropdown = document.getElementById('city-dropdown');
  dropdown.innerHTML = '';
  
  // Get current city
  const currentCity = gameConfig.currentCity;
  
  // Fetch 5 random cities including the current one
  fetch(`/api/cities/random?count=4&exclude=${currentCity.id}`)
    .then(response => response.json())
    .then(cities => {
      // Add current city to the mix
      cities.push(currentCity);
      
      // Shuffle the options
      cities.sort(() => Math.random() - 0.5);
      
      // Add to dropdown
      cities.forEach(city => {
        const option = document.createElement('option');
        option.value = city.id;
        option.textContent = city.name;
        dropdown.appendChild(option);
      });
    });
}

function startRound() {
  // Clear previous markers
  markers.forEach(marker => map.removeLayer(marker));
  markers = [];
  
  // Reset input fields
  document.getElementById('city-input').value = '';
  document.getElementById('autocomplete-suggestions').innerHTML = '';
  
  // Fetch a random city based on filters
  const filters = {
    countries: gameConfig.filters.countries,
    minPopulation: gameConfig.filters.minPopulation,
    exclude: gameConfig.guessedCities.map(g => g.cityId)
  };
  
  fetch('/api/cities/random', {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json'
    },
    body: JSON.stringify(filters)
  })
    .then(response => response.json())
    .then(city => {
      gameConfig.currentCity = city;
      
      // Center map on city
      map.setView([city.latitude, city.longitude], 5);
      
      // Add marker
      const marker = L.marker([city.latitude, city.longitude]).addTo(map);
      markers.push(marker);
      
      // Update input mode if needed
      if (gameConfig.inputMode === 'dropdown') {
        loadDropdownOptions();
      }
    });
}

function handleCityInput(e) {
  if (gameConfig.inputMode !== 'autocomplete') {
    return;
  }
  
  const input = e.target.value;
  if (input.length < 3) {
    document.getElementById('autocomplete-suggestions').innerHTML = '';
    return;
  }
  
  // Fetch autocomplete suggestions
  fetch(`/api/cities/autocomplete?query=${input}`)
    .then(response => response.json())
    .then(suggestions => {
      const suggestionsContainer = document.getElementById('autocomplete-suggestions');
      suggestionsContainer.innerHTML = '';
      
      suggestions.forEach(city => {
        const suggestion = document.createElement('div');
        suggestion.classList.add('suggestion');
        suggestion.textContent = `${city.name}, ${city.country}`;
        suggestion.addEventListener('click', () => {
          document.getElementById('city-input').value = city.name;
          suggestionsContainer.innerHTML = '';
          // Store selected city ID for submission
          document.getElementById('city-input').dataset.cityId = city.id;
        });
        suggestionsContainer.appendChild(suggestion);
      });
    });
}

function submitGuess() {
  let guessedCityId;
  
  if (gameConfig.inputMode === 'dropdown') {
    guessedCityId = document.getElementById('city-dropdown').value;
  } else {
    // For autocomplete, we get the ID from the data attribute if available
    const cityInput = document.getElementById('city-input');
    if (gameConfig.inputMode === 'autocomplete' && cityInput.dataset.cityId) {
      guessedCityId = cityInput.dataset.cityId;
    } else {
      // For freetext, we need to search for the city by name
      const cityName = cityInput.value.trim();
      if (!cityName) {
        alert('Please enter a city name');
        return;
      }
      
      // Search for city by name
      fetch(`/api/cities/search?name=${encodeURIComponent(cityName)}`)
        .then(response => response.json())
        .then(city => {
          if (city) {
            processGuess(city.id);
          } else {
            alert('City not found. Please try another name.');
          }
        });
      return;
    }
  }
  
  processGuess(guessedCityId);
}

function processGuess(guessedCityId) {
  fetch(`/api/cities/${guessedCityId}`)
    .then(response => response.json())
    .then(guessedCity => {
      const actualCity = gameConfig.currentCity;
      
      // Calculate distance
      const distance = calculateDistance(
        actualCity.latitude, actualCity.longitude,
        guessedCity.latitude, guessedCity.longitude
      );
      
      // Calculate points (inverse logarithmic to distance)
      const points = calculatePoints(distance);
      
      // Update score
      gameConfig.score += points;
      
      // Store guess for history
      gameConfig.guessedCities.push({
        round: gameConfig.currentRound,
        cityId: actualCity.id,
        cityName: actualCity.name,
        guessedCityId: guessedCity.id,
        guessedCityName: guessedCity.name,
        distance,
        points
      });
      
      // Show result screen
      showResultScreen(actualCity, guessedCity, distance, points);
    });
}

function calculateDistance(lat1, lon1, lat2, lon2) {
  // Haversine formula to calculate distance between two points
  const R = 6371; // Radius of the Earth in km
  const dLat = (lat2 - lat1) * Math.PI / 180;
  const dLon = (lon2 - lon1) * Math.PI / 180;
  const a = 
    Math.sin(dLat/2) * Math.sin(dLat/2) +
    Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) * 
    Math.sin(dLon/2) * Math.sin(dLon/2);
  const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
  const distance = R * c; // Distance in km
  
  return distance;
}

function calculatePoints(distance) {
  // Inverse logarithmic scoring based on distance
  // Perfect score is 1000 points (if distance is 0)
  if (distance < 1) return 1000; // If almost perfect (<1km), give max score
  
  // As distance increases, score decreases logarithmically
  const points = Math.max(0, Math.round(1000 / Math.log10(distance + 10)));
  return points;
}

function showResultScreen(actualCity, guessedCity, distance, points) {
  document.getElementById('actual-city').textContent = `${actualCity.name}, ${actualCity.country}`;
  document.getElementById('guessed-city').textContent = `${guessedCity.name}, ${guessedCity.country}`;
  document.getElementById('distance').textContent = `${Math.round(distance)} km`;
  document.getElementById('points-earned').textContent = points;
  
  // Show both cities on map
  map.setView([
    (actualCity.latitude + guessedCity.latitude) / 2,
    (actualCity.longitude + guessedCity.longitude) / 2
  ], getZoomLevelForDistance(distance));
  
  // Add markers and line
  markers.forEach(marker => map.removeLayer(marker));
  markers = [];
  
  const actualMarker = L.marker([actualCity.latitude, actualCity.longitude], {
    icon: L.divIcon({
      className: 'actual-city-marker',
      html: '<div class="marker-icon actual"></div>',
      iconSize: [20, 20]
    })
  }).addTo(map);
  markers.push(actualMarker);
  
  const guessMarker = L.marker([guessedCity.latitude, guessedCity.longitude], {
    icon: L.divIcon({
      className: 'guessed-city-marker',
      html: '<div class="marker-icon guess"></div>',
      iconSize: [20, 20]
    })
  }).addTo(map);
  markers.push(guessMarker);
  
  // Add line between them
  const line = L.polyline([
    [actualCity.latitude, actualCity.longitude],
    [guessedCity.latitude, guessedCity.longitude]
  ], {
    color: 'red',
    dashArray: '5, 5',
    weight: 2
  }).addTo(map);
  markers.push(line); // Add to markers array for easy cleanup
  
  // Update score display
  document.getElementById('current-score').textContent = gameConfig.score;
  
  // Show result screen
  hideAllScreens();
  document.getElementById('result-screen').classList.remove('hidden');
  
  // Keep map visible in result screen
  document.getElementById('map-container').style.display = 'block';
}

function getZoomLevelForDistance(distance) {
  if (distance < 50) return 8;
  if (distance < 200) return 6;
  if (distance < 500) return 5;
  if (distance < 2000) return 4;
  return 3;
}

function nextRound() {
  gameConfig.currentRound++;
  
  if (gameConfig.currentRound > gameConfig.totalRounds) {
    showGameOverScreen();
  } else {
    // Update round display
    document.getElementById('current-round').textContent = gameConfig.currentRound;
    
    // Show game screen
    hideAllScreens();
    document.getElementById('game-screen').classList.remove('hidden');
    
    // Start next round
    startRound();
  }
}

function showGameOverScreen() {
  document.getElementById('final-score').textContent = gameConfig.score;
  
  // Generate guesses summary
  const summaryContainer = document.getElementById('guesses-summary');
  summaryContainer.innerHTML = '<h3>Your Guesses</h3>';
  
  const summaryTable = document.createElement('table');
  summaryTable.classList.add('guesses-table');
  
  // Add header row
  const headerRow = document.createElement('tr');
  headerRow.innerHTML = `
    <th>Round</th>
    <th>Actual City</th>
    <th>Your Guess</th>
    <th>Distance</th>
    <th>Points</th>
  `;
  summaryTable.appendChild(headerRow);
  
  // Add data rows
  gameConfig.guessedCities.forEach(guess => {
    const row = document.createElement('tr');
    row.innerHTML = `
      <td>${guess.round}</td>
      <td>${guess.cityName}</td>
      <td>${guess.guessedCityName}</td>
      <td>${Math.round(guess.distance)} km</td>
      <td>${guess.points}</td>
    `;
    summaryTable.appendChild(row);
  });
  
  summaryContainer.appendChild(summaryTable);
  
  // Show game over screen
  hideAllScreens();
  document.getElementById('game-over-screen').classList.remove('hidden');
}

function saveScore() {
  const scoreData = {
    username: gameConfig.username,
    score: gameConfig.score,
    gameMode: gameConfig.gameMode,
    rounds: gameConfig.totalRounds,
    guesses: gameConfig.guessedCities
  };
  
  fetch('/api/scores', {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json'
    },
    body: JSON.stringify(scoreData)
  })
    .then(response => response.json())
    .then(result => {
      alert('Score saved successfully!');
      document.getElementById('save-score').disabled = true;
    })
    .catch(error => {
      alert('Failed to save score. Please try again.');
    });
}

function resetGame() {
  showStartScreen();
}

function loadCountriesForMultiselect() {
  fetch('/api/countries')
    .then(response => response.json())
    .then(countries => {
      const countrySelect = document.getElementById('country-select');
      countrySelect.innerHTML = '';
      
      countries.forEach(country => {
        const option = document.createElement('option');
        option.value = country.code;
        option.textContent = country.name;
        countrySelect.appendChild(option);
      });
    });
}

// Helper function to make API requests
async function apiRequest(endpoint, method = 'GET', data = null) {
  const options = {
    method,
    headers: {
      'Content-Type': 'application/json'
    }
  };
  
  if (data) {
    options.body = JSON.stringify(data);
  }
  
  const response = await fetch(`/api/${endpoint}`, options);
  return await response.json();
}

================
File: public/styles.css
================
/* styles.css - Main stylesheet for City Guessing Game */

/* Base styles */
:root {
  --primary-color: #2c3e50;
  --secondary-color: #3498db;
  --accent-color: #e74c3c;
  --light-color: #ecf0f1;
  --dark-color: #34495e;
  --success-color: #2ecc71;
  --warning-color: #f39c12;
  --border-radius: 4px;
  --box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
}

* {
  box-sizing: border-box;
  margin: 0;
  padding: 0;
}

body {
  font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
  line-height: 1.6;
  color: var(--dark-color);
  background-color: var(--light-color);
}

/* Container styles */
.game-container {
  max-width: 1000px;
  margin: 0 auto;
  padding: 20px;
}

/* Screen styles */
.screen {
  background-color: white;
  border-radius: var(--border-radius);
  box-shadow: var(--box-shadow);
  padding: 20px;
  margin-bottom: 20px;
}

.hidden {
  display: none;
}

/* Heading styles */
h1 {
  text-align: center;
  color: var(--primary-color);
  margin-bottom: 30px;
}

h2 {
  color: var(--primary-color);
  margin-bottom: 20px;
}

h3 {
  color: var(--dark-color);
  margin-bottom: 15px;
  font-size: 18px;
}

/* Form control styles */
.form-group {
  margin-bottom: 15px;
}

label {
  display: block;
  margin-bottom: 5px;
  font-weight: 600;
}

.input-field, .select-field {
  width: 100%;
  padding: 10px;
  border: 1px solid #ddd;
  border-radius: var(--border-radius);
  font-size: 16px;
}

.input-field:focus, .select-field:focus {
  outline: none;
  border-color: var(--secondary-color);
  box-shadow: 0 0 0 2px rgba(52, 152, 219, 0.2);
}

select[multiple] {
  height: 150px;
}

.checkbox-group, .radio-group {
  margin-bottom: 10px;
}

.checkbox-group input, .radio-group input {
  margin-right: 10px;
}

/* Button styles */
.btn {
  display: inline-block;
  padding: 10px 20px;
  margin: 5px 0;
  border: none;
  border-radius: var(--border-radius);
  cursor: pointer;
  font-size: 16px;
  font-weight: 600;
  text-align: center;
  transition: background-color 0.3s, transform 0.2s;
}

.btn:disabled {
  opacity: 0.7;
  cursor: not-allowed;
}

.primary-btn {
  background-color: var(--secondary-color);
  color: white;
}

.primary-btn:hover:not(:disabled) {
  background-color: #2980b9;
  transform: translateY(-2px);
}

.secondary-btn {
  background-color: var(--light-color);
  color: var(--dark-color);
  border: 1px solid #ddd;
}

.secondary-btn:hover:not(:disabled) {
  background-color: #ddd;
  transform: translateY(-2px);
}

/* Map styles */
#map-container {
  height: 400px;
  margin: 20px 0;
  border-radius: var(--border-radius);
  box-shadow: var(--box-shadow);
}

/* Game header styles */
.game-header {
  display: flex;
  justify-content: space-between;
  margin-bottom: 15px;
}

.score-display, .round-display {
  font-size: 18px;
  font-weight: 600;
  color: var(--primary-color);
}

/* Guess container styles */
.guess-container {
  margin-top: 20px;
}

.input-container {
  margin-bottom: 15px;
}

/* Autocomplete styles */
#autocomplete-suggestions {
  position: absolute;
  background-color: white;
  width: 100%;
  max-height: 200px;
  overflow-y: auto;
  box-shadow: var(--box-shadow);
  border: 1px solid #ddd;
  border-top: none;
  border-radius: 0 0 var(--border-radius) var(--border-radius);
  z-index: 1000;
}

.suggestion {
  padding: 10px;
  cursor: pointer;
}

.suggestion:hover {
  background-color: var(--light-color);
}

/* Result styles */
.result-details {
  margin: 20px 0;
  font-size: 18px;
}

.result-details p {
  margin-bottom: 10px;
}

/* Game over styles */
.final-score {
  font-size: 24px;
  font-weight: 600;
  text-align: center;
  margin: 20px 0;
  color: var(--primary-color);
}

/* Guesses table styles */
.guesses-table {
  width: 100%;
  border-collapse: collapse;
  margin: 20px 0;
}

.guesses-table th, .guesses-table td {
  border: 1px solid #ddd;
  padding: 10px;
  text-align: left;
}

.guesses-table th {
  background-color: var(--primary-color);
  color: white;
}

.guesses-table tr:nth-child(even) {
  background-color: var(--light-color);
}

/* Marker icons */
.marker-icon {
  width: 20px;
  height: 20px;
  border-radius: 50%;
  border: 2px solid white;
}

.marker-icon.actual {
  background-color: var(--accent-color);
}

.marker-icon.guess {
  background-color: var(--secondary-color);
}

/* Settings styles */
.settings-group {
  margin-bottom: 20px;
  padding-bottom: 15px;
  border-bottom: 1px solid #ddd;
}

/* Responsive styles */
@media (max-width: 768px) {
  .game-container {
    padding: 10px;
  }
  
  #map-container {
    height: 300px;
  }
  
  .btn {
    width: 100%;
    margin-bottom: 10px;
  }
  
  .game-header {
    flex-direction: column;
    align-items: center;
  }
  
  .score-display, .round-display {
    margin-bottom: 10px;
  }
}

================
File: csvLoader.js
================
// csvLoader.js - Script to load city data from CSV file into PostgreSQL

const fs = require('fs');
const { Pool } = require('pg');
const { parse } = require('csv-parse');
const path = require('path');

// Database connection
const pool = new Pool({
  user: process.env.DB_USER || 'postgres',
  host: process.env.DB_HOST || 'localhost',
  database: process.env.DB_NAME || 'city_game',
  password: process.env.DB_PASSWORD || 'postgres',
  port: process.env.DB_PORT || 5432,
});

async function loadCitiesFromCSV() {
  try {
    // Check if data is already loaded
    const countResult = await pool.query('SELECT COUNT(*) FROM cities');
    if (parseInt(countResult.rows[0].count) > 0) {
      console.log('Cities table already has data, skipping import.');
      return;
    }

    console.log('Starting CSV import...');
    
    // Path to CSV file
    const csvFilePath = path.join(__dirname, 'cities.csv');
    
    // Read the CSV file
    const fileContent = fs.readFileSync(csvFilePath, { encoding: 'utf-8' });
    
    // Parse the CSV
    parse(fileContent, {
      columns: true,
      skip_empty_lines: true,
      trim: true
    }, async (err, records) => {
      if (err) {
        console.error('Error parsing CSV:', err);
        return;
      }
      
      console.log(`Found ${records.length} cities in the CSV file.`);
      
      // Use a connection from the pool
      const client = await pool.connect();
      
      try {
        await client.query('BEGIN');
        
        // Prepare the query
        const query = `
          INSERT INTO cities (
            city, city_ascii, city_alt, lat, lng, country, 
            iso2, iso3, admin_name, admin_name_ascii, admin_code, 
            admin_type, capital, density, population, population_proper, 
            ranking, timezone, same_name, original_id
          ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18, $19, $20)
        `;
        
        // Process records in batches
        const batchSize = 1000;
        let count = 0;
        
        for (let i = 0; i < records.length; i++) {
          const record = records[i];
          
          // Check if record has required fields
          if (!record.city || !record.lat || !record.lng || !record.country) {
            console.warn(`Skipping record at index ${i}: Missing required fields`);
            continue;
          }
          
          // Parse numeric values
          const lat = parseFloat(record.lat);
          const lng = parseFloat(record.lng);
          const density = record.density ? parseFloat(record.density) : null;
          const population = record.population ? parseInt(record.population, 10) : null;
          const population_proper = record.population_proper ? parseInt(record.population_proper, 10) : null;
          const ranking = record.ranking ? parseInt(record.ranking, 10) : null;
          const same_name = record.same_name === 'true' || record.same_name === '1';
          
          // Insert the record
          await client.query(query, [
            record.city,
            record.city_ascii || record.city,
            record.city_alt || null,
            lat,
            lng,
            record.country,
            record.iso2 || '',
            record.iso3 || '',
            record.admin_name || null,
            record.admin_name_ascii || null,
            record.admin_code || null,
            record.admin_type || null,
            record.capital || null,
            density,
            population,
            population_proper,
            ranking,
            record.timezone || null,
            same_name,
            record.id || null
          ]);
          
          count++;
          
          // Log progress
          if (count % batchSize === 0 || count === records.length) {
            console.log(`Imported ${count}/${records.length} cities...`);
          }
        }
        
        await client.query('COMMIT');
        console.log(`CSV import completed successfully. Imported ${count} cities.`);
        
      } catch (error) {
        await client.query('ROLLBACK');
        console.error('Error importing CSV data:', error);
      } finally {
        client.release();
      }
    });
    
  } catch (error) {
    console.error('Error in CSV load process:', error);
  }
}

// Call the function to load cities
loadCitiesFromCSV().then(() => {
  console.log('CSV loading process completed');
  pool.end();
}).catch(err => {
  console.error('Fatal error in CSV loading process:', err);
  pool.end();
});

================
File: package.json
================
{
  "name": "city-guessing-game",
  "version": "1.0.0",
  "description": "A map-based city guessing game with multiple difficulty levels",
  "main": "server.js",
  "scripts": {
    "start": "node server.js",
    "dev": "cross-env NODE_ENV=development nodemon server.js",
    "build": "mkdir -p public && cp -r client/* public/",
    "load-csv": "node csvLoader.js"
  },
  "dependencies": {
    "cors": "^2.8.5",
    "csv-parse": "^5.3.0",
    "express": "^4.17.1",
    "pg": "^8.7.1"
  },
  "devDependencies": {
    "cross-env": "^7.0.3",
    "nodemon": "^2.0.15"
  },
  "engines": {
    "node": ">=14.0.0"
  },
  "author": "",
  "license": "MIT"
}

================
File: server.js
================
// server.js - Express backend for the City Guessing Game
const express = require('express');
const cors = require('cors');
const { Pool } = require('pg');
const path = require('path');

// Initialize Express app
const app = express();
const PORT = process.env.PORT || 3000;

// Middleware
app.use(cors());
app.use(express.json());
app.use(express.static(path.join(__dirname, 'public')));

// Add a data seeding script for development
async function seedDatabaseWithSampleData() {
  // Import and run the CSV loader instead of manual seeding
  try {
    console.log('Attempting to load data from CSV file...');
    require('./csvLoader');
  } catch (err) {
    console.error('Error loading CSV data:', err);
  }
}

// Start server
app.listen(PORT, () => {
  console.log(`Server running on port ${PORT}`);
  
  // For development, seed the database with sample data
  if (process.env.NODE_ENV === 'development') {
    seedDatabaseWithSampleData().catch(err => {
      console.error('Error seeding database:', err);
    });
  }
});

// Serve main HTML file for all routes (SPA)
app.get('*', (req, res) => {
  res.sendFile(path.join(__dirname, 'public', 'index.html'));
});

// Database connection
const pool = new Pool({
  user: process.env.DB_USER || 'postgres',
  host: process.env.DB_HOST || 'localhost',
  database: process.env.DB_NAME || 'city_game',
  password: process.env.DB_PASSWORD || 'postgres',
  port: process.env.DB_PORT || 5432,
});

// Create database tables if they don't exist
async function initializeDatabase() {
  const client = await pool.connect();
  try {
    await client.query('BEGIN');
    
    // Create cities table with fields matching the CSV
    await client.query(`
      CREATE TABLE IF NOT EXISTS cities (
        id SERIAL PRIMARY KEY,
        city VARCHAR(100) NOT NULL,
        city_ascii VARCHAR(100) NOT NULL,
        city_alt VARCHAR(100),
        lat DECIMAL(9,6) NOT NULL,
        lng DECIMAL(9,6) NOT NULL,
        country VARCHAR(100) NOT NULL,
        iso2 CHAR(2) NOT NULL,
        iso3 CHAR(3) NOT NULL,
        admin_name VARCHAR(100),
        admin_name_ascii VARCHAR(100),
        admin_code VARCHAR(50),
        admin_type VARCHAR(50),
        capital VARCHAR(50),
        density DECIMAL(15,2),
        population BIGINT,
        population_proper BIGINT,
        ranking INT,
        timezone VARCHAR(50),
        same_name BOOLEAN,
        original_id VARCHAR(50)
      )
    `);
    
    // Create scores table
    await client.query(`
      CREATE TABLE IF NOT EXISTS scores (
        id SERIAL PRIMARY KEY,
        username VARCHAR(50) NOT NULL,
        score INTEGER NOT NULL,
        game_mode VARCHAR(20) NOT NULL,
        rounds INTEGER NOT NULL,
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
      )
    `);
    
    // Create guesses table to store detailed game history
    await client.query(`
      CREATE TABLE IF NOT EXISTS guesses (
        id SERIAL PRIMARY KEY,
        score_id INTEGER REFERENCES scores(id) ON DELETE CASCADE,
        round_number INTEGER NOT NULL,
        actual_city_id INTEGER REFERENCES cities(id),
        guessed_city_id INTEGER REFERENCES cities(id),
        distance DECIMAL(10,2) NOT NULL,
        points INTEGER NOT NULL
      )
    `);
    
    await client.query('COMMIT');
    console.log('Database tables initialized successfully');
  } catch (e) {
    await client.query('ROLLBACK');
    console.error('Database initialization error:', e);
    throw e;
  } finally {
    client.release();
  }
}

// Test database connection and initialize
pool.query('SELECT NOW()', (err, res) => {
  if (err) {
    console.error('Database connection error:', err);
  } else {
    console.log('Database connected successfully');
    initializeDatabase().catch(err => console.error('Database initialization error:', err));
  }
});

// API Routes

// Get random cities for dropdown options
app.get('/api/cities/random', async (req, res) => {
  try {
    const count = parseInt(req.query.count) || 5;
    const excludeId = req.query.exclude;
    
    let query = `
      SELECT c.id, c.city as name, c.country
      FROM cities c
      WHERE 1=1
    `;
    
    const params = [];
    
    if (excludeId) {
      query += ` AND c.id != $1`;
      params.push(excludeId);
    }
    
    query += ` ORDER BY RANDOM() LIMIT ${count}`;
    
    const result = await pool.query(query, params);
    res.json(result.rows);
  } catch (error) {
    console.error('Error fetching random cities:', error);
    res.status(500).json({ error: 'Failed to fetch random cities' });
  }
});

// Get city by ID
app.get('/api/cities/:id', async (req, res) => {
  try {
    const { id } = req.params;
    
    const query = `
      SELECT c.id, c.city as name, c.lat as latitude, c.lng as longitude, c.country
      FROM cities c
      WHERE c.id = $1
    `;
    
    const result = await pool.query(query, [id]);
    
    if (result.rows.length === 0) {
      return res.status(404).json({ error: 'City not found' });
    }
    
    res.json(result.rows[0]);
  } catch (error) {
    console.error('Error fetching city:', error);
    res.status(500).json({ error: 'Failed to fetch city' });
  }
});

// Search for city by name
app.get('/api/cities/search', async (req, res) => {
  try {
    const { name } = req.query;
    
    if (!name) {
      return res.status(400).json({ error: 'Name parameter is required' });
    }
    
    const query = `
      SELECT c.id, c.city as name, c.lat as latitude, c.lng as longitude, c.country
      FROM cities c
      WHERE LOWER(c.city) = LOWER($1) OR LOWER(c.city_ascii) = LOWER($1)
      LIMIT 1
    `;
    
    const result = await pool.query(query, [name]);
    
    if (result.rows.length === 0) {
      return res.status(404).json({ error: 'City not found' });
    }
    
    res.json(result.rows[0]);
  } catch (error) {
    console.error('Error searching city:', error);
    res.status(500).json({ error: 'Failed to search city' });
  }
});

// Autocomplete city names
app.get('/api/cities/autocomplete', async (req, res) => {
  try {
    const { query } = req.query;
    
    if (!query || query.length < 2) {
      return res.json([]);
    }
    
    const sqlQuery = `
      SELECT c.id, c.city as name, c.country
      FROM cities c
      WHERE LOWER(c.city) LIKE LOWER($1) OR LOWER(c.city_ascii) LIKE LOWER($1)
      ORDER BY 
        CASE WHEN LOWER(c.city) = LOWER($2) THEN 0
             WHEN LOWER(c.city) LIKE LOWER($2 || '%') THEN 1
             ELSE 2
        END,
        population DESC NULLS LAST
      LIMIT 10
    `;
    
    const result = await pool.query(sqlQuery, [`%${query}%`, query]);
    res.json(result.rows);
  } catch (error) {
    console.error('Error fetching autocomplete suggestions:', error);
    res.status(500).json({ error: 'Failed to fetch autocomplete suggestions' });
  }
});

// Save score
app.post('/api/scores', async (req, res) => {
  const client = await pool.connect();
  try {
    await client.query('BEGIN');
    
    const { username, score, gameMode, rounds, guesses } = req.body;
    
    // Insert score
    const scoreResult = await client.query(
      `INSERT INTO scores (username, score, game_mode, rounds) 
       VALUES ($1, $2, $3, $4) RETURNING id`,
      [username, score, gameMode, rounds]
    );
    
    const scoreId = scoreResult.rows[0].id;
    
    // Insert guesses
    for (const guess of guesses) {
      await client.query(
        `INSERT INTO guesses (score_id, round_number, actual_city_id, guessed_city_id, distance, points)
         VALUES ($1, $2, $3, $4, $5, $6)`,
        [scoreId, guess.round, guess.cityId, guess.guessedCityId, guess.distance, guess.points]
      );
    }
    
    await client.query('COMMIT');
    
    res.json({ success: true, id: scoreId });
  } catch (error) {
    await client.query('ROLLBACK');
    console.error('Error saving score:', error);
    res.status(500).json({ error: 'Failed to save score' });
  } finally {
    client.release();
  }
});

// Get high scores
app.get('/api/scores/highscores', async (req, res) => {
  try {
    const { mode, limit } = req.query;
    const scoreLimit = parseInt(limit) || 10;
    
    let query = `
      SELECT username, score, game_mode, rounds, created_at
      FROM scores
      WHERE 1=1
    `;
    
    const params = [];
    
    if (mode) {
      query += ` AND game_mode = $1`;
      params.push(mode);
    }
    
    query += ` ORDER BY score DESC LIMIT ${scoreLimit}`;
    
    const result = await pool.query(query, params);
    res.json(result.rows);
  } catch (error) {
    console.error('Error fetching high scores:', error);
    res.status(500).json({ error: 'Failed to fetch high scores' });
  }
});

// Get GeoJSON data for country borders
app.get('/api/geojson/countries', (req, res) => {
  // In a real application, you would fetch this from a database
  // or a file, but for simplicity, we'll use a URL to a GeoJSON file
  res.json({
    type: 'FeatureCollection',
    features: [] // This would be populated with actual GeoJSON data
  });
});

// Get GeoJSON data for state/provincial borders
app.get('/api/geojson/states', (req, res) => {
  // Same as above, this would be fetched from a database or file
  res.json({
    type: 'FeatureCollection',
    features: [] // This would be populated with actual GeoJSON data
  });
});

// Get all countries
app.get('/api/countries', async (req, res) => {
  try {
    const result = await pool.query('SELECT code, name FROM countries ORDER BY name');
    res.json(result.rows);
  } catch (error) {
    console.error('Error fetching countries:', error);
    res.status(500).json({ error: 'Failed to fetch countries' });
  }
});

// Get random city based on filters
app.post('/api/cities/random', async (req, res) => {
  try {
    const { countries, minPopulation, exclude } = req.body;
    
    let query = `
      SELECT c.id, c.city as name, c.lat as latitude, c.lng as longitude, c.country
      FROM cities c
      WHERE 1=1
    `;
    
    const params = [];
    let paramCounter = 1;
    
    // Add population filter if provided
    if (minPopulation) {
      query += ` AND (c.population >= ${paramCounter} OR c.population_proper >= ${paramCounter})`;
      params.push(minPopulation);
      paramCounter++;
    }
    
    // Add country filter if provided
    if (countries && countries.length > 0) {
      query += ` AND c.iso2 IN (${countries.map((_, i) => `${paramCounter + i}`).join(',')})`;
      params.push(...countries);
      paramCounter += countries.length;
    }
    
    // Exclude cities that have already been used
    if (exclude && exclude.length > 0) {
      query += ` AND c.id NOT IN (${exclude.map((_, i) => `${paramCounter + i}`).join(',')})`;
      params.push(...exclude);
    }
    
    // Get random city
    query += ' ORDER BY RANDOM() LIMIT 1';
    
    const result = await pool.query(query, params);
    
    if (result.rows.length === 0) {
      return res.status(404).json({ error: 'No cities found matching criteria' });
    }
    
    res.json(result.rows[0]);
  } catch (error) {
    console.error('Error fetching random city:', error);
    res.status(500).json({ error: 'Failed to fetch random city' });
  }
});
